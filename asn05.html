<!DOCTYPE html>
<html lang="en">
<head>
<title>Graphics - Assignment 5</title>
<link rel="stylesheet" type="text/css"  href="style.css">
</head>
<body>
Points Data: <input type="file" id="pointsdata" name="file" /> <br/>
Line Data: <input type="file" id="linedata" name="file" /> <br/>

<button onclick="readPointsFile()">Save</button>
<button onclick="draw()">Draw</button><br/> <br/>
<button onclick="translateY(35)">Translate Up</button>
<button onclick="translateY(-35)">Translate Down</button> <br/>
<button onclick="translateX(-75)">Translate Left</button>
<button onclick="translateX(75)">Translate Right</button> <br/> <br/>
<button onclick="scale(1.1)">Scale Up</button>
<button onclick="scale(0.9)">Scale Down</button> <br /> <br/>
<button onclick="shear(1)">Shear Left</button>
<button onclick="shear(1)">Shear Right</button> <br /> <br/>
<button onclick="rotateX()">Rotate X</button> <br /> 
<button onclick="rotateY()">Rotate Y</button> <br /> 
<button onclick="rotateZ()">Rotate Z</button><br/><br/>
<button onclick="contRotateX()">Continuous Rotate X</button><br/>
<button onclick="contRotateY()">Continuous Rotate Y</button> <br/>
<button onclick="contRotateZ()">Continuous Rotate Z</button><br/>
<button onclick="stopContRotate()">Stop Rotation</button> <br/>
    
<canvas id="myCanvas" style="border:1px solid #d3d3d3;">
Your browser does not support the canvas element.
</canvas>
    
</body>
</html>

<script>
var points;
var lines;
var transMatrix; //current translation matrix
    
function translateY(n) {
    
    // [ 1 0 0 0 ]
    // [ 0 1 0 0 ]
    // [ 0 0 1 0 ]
    // [ 0 n 0 1 ]
    
    transMatrix[3][1] = n;
    
    matrixMultiply();
    console.log(points);
    
    draw()
    //reset
    transMatrix[3][1] = 0;
}
    
function translateX(n) {
    
    // [ 1 0 0 0 ]
    // [ 0 1 0 0 ]
    // [ 0 0 1 0 ]
    // [ n 0 0 1 ]
    
    transMatrix[3][0] = n;
    
    matrixMultiply();
    console.log(points);
    
    draw()
    //reset
    transMatrix[3][0] = 0;
}

function scale(n) {
    var moveX = points[0][0];
    var moveY = points[0][1];
    var moveZ = points[0][2];
    
    //move back to origin assuming that point '0' is the center of the object
    transMatrix[3][0] -= moveX;
    transMatrix[3][1] -= moveY;
    transMatrix[3][2] -= moveZ;
    
    //scale factor
    transMatrix[0][0] = n;
    transMatrix[1][1] = n;
    transMatrix[2][2] = n;
        
    // [ n  0  0  0 ]
    // [ 0  n  0  0 ]
    // [ 0  0  n  0 ]
    // [ -x -y -z 1 ]
    
    matrixMultiply();
    
    //return to original position
    resetMatrix();
    transMatrix[3][0] += moveX;
    transMatrix[3][1] += moveY;
    transMatrix[3][2] += moveZ;
    
    // [ 1  0  0  0 ]
    // [ 0  1  0  0 ]
    // [ 0  0  1  0 ]
    // [ +x +y +z 1 ]
    
    //draw()
    matrixMultiply();
    console.log(points);
    //reset
    resetMatrix();
}
    
function shear(n) {
    
    // [ 1 ? 0 0 ]
    // [ ? 1 0 0 ]
    // [ 0 0 1 0 ]
    // [ 0 0 0 1 ]
    
}
    
function rotateX() {
    // cos(.05r) = 1
    // sin(.05r) = 0.05
    
    //r(x)
    // [ 1  0   0   0 ]
    // [ 0  1  -.05 0 ]
    // [ 0  .05  1  0 ]
    // [ 0   0   0  1 ]
    
}
    
function rotateY() {
    // cos(.05r) = 1
    // sin(.05r) = 0.05
    
    //r(y)
    // [  1   0  .05  0 ]
    // [  0   1   0   0 ]
    // [ -.05 0   1   0 ]
    // [  0   0   0   1 ]
    
}
    
function rotateZ() {
    // cos(.05r) = 1
    // sin(.05r) = 0.05

    //r(z)
    // [  1  -.05  0   0 ]
    // [ .05   1   0   0 ]
    // [  0    0   1   0 ]
    // [  0    0   0   1 ]
    
}
    
function contRotateX() {
    
    // while (something)
    // call rotateX repeatedly
    
}
    
function contRotateX() {
    
    // while (something)
    // call rotateY repeatedly
    
}
    
function contRotateX() {
    
    // while (something)
    // call rotateY repeatedly
    
}
    
function stopContRotate() {
    
    // stop it somehow lol
    
}
    
//multiplies the 'points' array with the current translation Matrix
function matrixMultiply() {
    
    for (var i = 0; typeof points[i] !== 'undefined'; i++) {
        points[i][0] = points[i][0]*transMatrix[0][0] + points[i][1]*transMatrix[1][0] 
            + points[i][2]*transMatrix[2][0] + points[i][3]*transMatrix[3][0];
        points[i][1] = points[i][0]*transMatrix[0][1] + points[i][1]*transMatrix[1][1] 
            + points[i][2]*transMatrix[2][1] + points[i][3]*transMatrix[3][1];
        points[i][2] = points[i][0]*transMatrix[0][2] + points[i][1]*transMatrix[1][2] 
            + points[i][2]*transMatrix[2][2] + points[i][3]*transMatrix[3][2];
        points[i][3] = points[i][0]*transMatrix[0][3] + points[i][1]*transMatrix[1][3] 
            + points[i][2]*transMatrix[2][3] + points[i][3]*transMatrix[3][3];
    }
}
    
function resetMatrix() {
    transMatrix[0] = [1, 0, 0, 0]; 
    transMatrix[1] = [0, 1, 0, 0];
    transMatrix[2] = [0, 0, 1, 0];
    transMatrix[3] = [0, 0, 0, 1];
}
    
function transform3d() {
    var pointX = points[i][0], pointY = points[i][1], pointZ = points[i][2];
    var newX, newY;

}
  
function draw() {
    var canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext("2d");
    canvas.width = 200;
    canvas.height = 200;
    
    /* //background color
    ctx.fillStyle = "rgb(0,0,0)";
    ctx.fillRect(0,0,200,200); */
    
    ctx.translate(0, canvas.height);
    ctx.scale(1, -1);
    ctx.strokeStyle = "rgb(0,0,0)"
    
    var t = points;

    /*for (var i = 0; typeof points[i] !== 'undefined'; i++) {
        console.log(points[i]);
        t[i] = transform3d(i, 200, 200, 100, 10);
        console.log(points[i]);
    }*/
    
    for(var i = 0; typeof lines[i] !== 'undefined'; i++ ) {
        var startX = Math.round(points[lines[i][0]][0]);
        var startY = Math.round(points[lines[i][0]][1]);
        var endX = Math.round(points[lines[i][1]][0]);
        var endY = Math.round(points[lines[i][1]][1]);
        
        //console.log(startX);
        //console.log(startY);
        //console.log(endX);
        //console.log(endY);
        
        ctx.beginPath();
        ctx.moveTo(startX*10,startY*10);
        ctx.lineTo(endX*10,endY*10);
        ctx.closePath();
        ctx.stroke();
        
    }
}
    
// File reading and storing into arrays    
function readPointsFile() {

    var files = document.getElementById('pointsdata').files;
    points = new Array(70);
    
    if (!files.length) {
        alert('Please select a points file!'); 
        return;
    } else {        
        // Perform points read
        var file = files[0];
        var start = 0;
        var stop = file.size - 1;
        var reader = new FileReader();
        
        reader.onloadend = function(evt) {
          if (evt.target.readyState == FileReader.DONE) { // DONE == 2 
              
              var result = evt.target.result.split("\n");
              var newlines = new Array(50);
              
              //stop reading at (-1)
              for (var i = 0; parseFloat(result[i]) != (-1); i++) {
                  newlines[i] = result[i];
              }
              
              //split lines by spaces and populate points array
              for (var j = 0; j < newlines.length; j++) {
                  if (newlines[j] == undefined) { return; }
                  var tmp = newlines[j].split(" ");
                  points[j] = new Array(4);
                  for (var k = 0; k < 3; k++) {
                      points[j][k] = parseFloat(tmp[k]);
                      points[j][3] = 1; //homogeneous coordinates
                  }
              }
          }
        };

        var blob = file.slice(start, stop + 1);
        reader.readAsBinaryString(blob);
        readLineFile();
    }
  }
    
function readLineFile() {

    var files = document.getElementById('linedata').files;
    if (!files.length) { alert('Please select a line file!'); return;}

    var file = files[0];
    var start = 0;
    var stop = file.size - 1;
    var reader = new FileReader();
    lines = new Array(50);

    // If we use onloadend, we need to check the readyState.
    reader.onloadend = function(evt) {
      if (evt.target.readyState == FileReader.DONE) { // DONE == 2
          
          var result = evt.target.result.split("\n");
          var newlines = new Array(80);
          
          //stop reading at (-1)
          for (var i = 0; parseFloat(result[i]) != (-1); i++) {
              newlines[i] = result[i];
          }
          
          //split lines by spaces and populate lines array
          for (var j = 0; j < newlines.length; j++) {
              if (newlines[j] == undefined) { return; }
              var tmp = newlines[j].split(" ");
              lines[j] = new Array(2);
              for (var k = 0; k < 2; k++) {
                  lines[j][k] = parseFloat(tmp[k]);
              }
          }
      }
    };

    var blob = file.slice(start, stop + 1);
    reader.readAsBinaryString(blob);
    transMatrix = new Array(3);
    resetMatrix();
  }
    
</script>